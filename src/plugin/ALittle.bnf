{
  parserClass="plugin.parser.ALittleParser"

  mixin="com.intellij.extapi.psi.ASTWrapperPsiElement"
  methods=[guessType guessTypes getReference]
  psiClassPrefix="ALittle"
  psiImplClassSuffix="Impl"
  psiPackage="plugin.psi"
  psiImplPackage="plugin.psi.impl"
  psiImplUtilClass="plugin.psi.ALittlePsiImplUtil"

  elementTypeHolderClass="plugin.psi.ALittleTypes"
  elementTypeClass="plugin.psi.ALittleElementType"
  tokenTypeClass="plugin.psi.ALittleTokenType"

  tokens=[
      LBRACE               =  '{'
      RBRACE               =  '}'
      LBRACK               =  '['
      RBRACK               =  ']'
      LPAREN               =  '('
      RPAREN               =  ')'
      COLON                =  ':'
      SEMI                 =  ';'
      COMMA                =  ','
      EQ                   =  '=='
      ASSIGN               =  '='
      NOT_EQ               =  '!='
      NOT                  =  '!'
      PLUS_PLUS            =  '++'
      PLUS_ASSIGN          =  '+='
      PLUS                 =  '+'
      CONCAT               =  '..'
      MINUS_MINUS          =  '--'
      MINUS_ASSIGN         =  '-='
      MINUS                =  '-'
      COND_OR              =  '||'
      COND_AND             =  '&&'
      LESS_OR_EQUAL        =  '<='
      LESS                 =  '<'
      MUL_ASSIGN           =  '*='
      MUL                  =  '*'
      QUOTIENT_ASSIGN      =  '/='
      QUOTIENT             =  '/'
      REMAINDER_ASSIGN     =  '%='
      REMAINDER            =  '%'
      GREATER_OR_EQUAL     =  '>='
      GREATER              =  '>'
      DOT                  =  '.'
      APOS                 =  "'"
      QUOTE                =  '"'
      BACK                 =  '\'
      HTTP                 =  '@Http'
      HTTP_DOWNLOAD        =  '@HttpDownload'
      HTTP_UPLOAD          =  '@HttpUpload'
      MSG                  =  '@Msg'
      TYPE_TAIL           =  '...'

      WHITE_SPACE          = 'regexp:\s+'
      COMMENT              = 'regexp://.*'
      DIGIT_CONTENT        = 'regexp:0x[0-9a-fA-F]+|\d+(\.\d*)?'
      STRING_CONTENT       = 'regexp:"([^"\\]|\\.)*"'
      ID_CONTENT           = 'regexp:[_a-zA-Z][_a-zA-Z0-9]*'
  ]
}

alittleFile ::= namespaceDec?

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 注册修饰符，如果有这个修饰，那么就不会生成目标代码
registerModifier ::= register
// 访问修饰符
accessModifier ::= public | private | protected
// 协程修饰符
coModifier ::= async | await
// 协议修饰符
protoModifier ::= HTTP | HTTP_DOWNLOAD | HTTP_UPLOAD |  MSG

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 命名域
namespaceDec ::= registerModifier? namespace namespaceNameDec SEMI (globalMethodDec | classDec | enumDec | structDec | instanceDec | usingDec | opAssignExpr | propertyValueExpr)* {pin=2}
namespaceNameDec ::= ID_CONTENT

// 模板定义
templateDec ::= LESS templatePairDec (COMMA templatePairDec)? GREATER {pin=1}
templatePairDec ::= ID_CONTENT templateExtendsDec? {pin=1}
private templateExtendsDec ::= COLON allType {pin=1}

// 类定义
classDec ::= accessModifier? class classNameDec templateDec? classExtendsDec? classBodyDec {pin=2}
classNameDec ::= ID_CONTENT
classExtendsDec ::= COLON accessModifier? (namespaceNameDec DOT)? classNameDec {pin=1}
private classBodyDec ::= LBRACE (classVarDec | classCtorDec | classGetterDec | classSetterDec | classStaticDec | classMethodDec)* RBRACE {pin=1}

// 结构体定义
structDec ::= accessModifier? struct structNameDec structExtendsDec? structBodyDec {pin=2}
structNameDec ::= ID_CONTENT
structExtendsDec ::= COLON (namespaceNameDec DOT)? structNameDec {pin=1}
private structBodyDec ::= LBRACE (structVarDec)* RBRACE {pin=1}

// 枚举定义
enumDec ::= accessModifier? enum enumNameDec enumBodyDec  {pin=2}
enumNameDec ::= ID_CONTENT
private enumBodyDec ::= LBRACE (enumVarDec(COMMA enumVarDec)* COMMA?)? RBRACE {pin=1}

// 全局变量
instanceDec ::= accessModifier? varAssignExpr {pin=2}

// using定义
usingDec ::= accessModifier? using usingNameDec ASSIGN allType SEMI {pin=2}
usingNameDec ::= ID_CONTENT

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 类成员变量定义
classVarDec ::= accessModifier? allType ID_CONTENT SEMI {pin=2}

// 结构体成员变量定义
structVarDec ::= allType ID_CONTENT SEMI {pin=1}

// 枚举成员定义
enumVarDec::= ID_CONTENT (ASSIGN (DIGIT_CONTENT | STRING_CONTENT))? {pin=1}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 函数参数部分
methodParamOneDec ::= allType methodParamNameDec {pin=1}
methodParamNameDec ::= ID_CONTENT
methodParamTailDec ::= TYPE_TAIL
methodReturnTailDec ::= TYPE_TAIL
methodParamDec ::= LPAREN ((methodParamOneDec methodParamPairDec* methodParamTailPairDec?) | methodParamTailDec)? RPAREN {pin=1}
private methodParamPairDec ::= COMMA methodParamOneDec
private methodParamTailPairDec ::= COMMA methodParamTailDec
// 函数体部分
methodBodyDec ::= LBRACE allExpr* RBRACE {pin=1}
// 函数名部分
methodNameDec ::= ID_CONTENT
// 函数返回值类型
methodReturnDec ::= COLON ((allType (COMMA allType)* methodReturnTailPairDec?) | methodReturnTailDec) {pin=1}
private methodReturnTailPairDec ::= COMMA methodReturnTailDec

// 类构造函数定义
classCtorDec ::= accessModifier? Ctor methodParamDec methodBodyDec {pin=2}
// 类getter函数
classGetterDec ::= accessModifier? get methodNameDec LPAREN RPAREN COLON allType methodBodyDec {pin=2}
// 类setter函数
classSetterDec ::= accessModifier? set methodNameDec LPAREN methodParamOneDec RPAREN methodBodyDec {pin=2}
// 类成员函数定义
classMethodDec ::= accessModifier? coModifier? fun methodNameDec methodParamDec methodReturnDec? methodBodyDec {pin=3}
// 类静态函数定义
classStaticDec ::= accessModifier? coModifier? static methodNameDec methodParamDec methodReturnDec? methodBodyDec {pin=3}
// 全局函数
globalMethodDec ::= protoModifier? accessModifier? coModifier? static methodNameDec methodParamDec methodReturnDec? methodBodyDec {pin=4}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 表达式
allExpr ::= varAssignExpr |
            opAssignExpr |
            op1Expr |
            ifExpr |
            forExpr |
            whileExpr |
            doWhileExpr |
            returnExpr |
            flowExpr |
            wrapExpr |
            propertyValueExpr |
            nsendExpr |
            throwExpr |
            assertExpr |
            emptyExpr

// 空语句
emptyExpr ::= SEMI

// for 流程控制
forExpr ::= for forCondition (forBody | allExpr) {pin=1}
private forCondition ::= LPAREN (forStepCondition | forInCondition) RPAREN {pin=1}
private forBody ::= LBRACE allExpr* RBRACE {pin=1}

forStepCondition ::= forStartStat forStepConditionEndStep
private forStepConditionEndStep ::= COMMA forEndStat forStepConditionStep {pin=1}
private forStepConditionStep ::= COMMA forStepStat {pin=1}
forStartStat ::= forPairDec ASSIGN valueStat {pin=2}
forEndStat ::= valueStat
forStepStat ::= valueStat

forInCondition ::= forPairDec forInConditionPairDec* forInConditionInDec {pin=1}
private forInConditionPairDec ::= COMMA forPairDec {pin=1}
private forInConditionInDec ::= in valueStat {pin=1}
forPairDec ::= (autoType | allType) varAssignNameDec {pin=1}

// while 流程控制
whileExpr ::= while whileCondition (whileBody | allExpr) {pin=1}
private whileCondition ::= LPAREN valueStat RPAREN {pin=1}
private whileBody ::= LBRACE allExpr* RBRACE {pin=1}

// do while 流程控制
doWhileExpr ::= do doWhileBody while doWhileCondition SEMI {pin=1}
private doWhileCondition ::= LPAREN valueStat RPAREN {pin=1}
private doWhileBody ::= LBRACE allExpr* RBRACE {pin=1}

// if else 流程控制
ifExpr ::= if ifCondition (ifBody | allExpr) elseIfExpr* elseExpr? {pin=1}
private ifCondition ::= LPAREN valueStat RPAREN {pin=1}
private ifBody ::= LBRACE allExpr* RBRACE {pin=1}
elseExpr ::= else (elseBody | allExpr) {pin=1}
private elseBody ::= LBRACE allExpr* RBRACE {pin=1}
elseIfExpr ::= elseif elseIfCondition (elseIfBody | allExpr) {pin=1}
private elseIfCondition ::= LPAREN valueStat RPAREN {pin=1}
private elseIfBody ::= LBRACE allExpr* RBRACE {pin=1}

// 表达式包装 比如 { 表达式列表 }
wrapExpr ::= LBRACE allExpr* RBRACE {pin=1}

// return
returnExpr ::= return ((valueStat (COMMA valueStat)*) | returnYield)? SEMI {pin=1}
returnYield ::= yield

// break, [ continue 后续添加功能 ]
flowExpr ::= break SEMI {pin=1}

// 定义语句
varAssignExpr ::= varAssignDec varAssignPairDec* varAssignValueStat? SEMI {pin=1}
private varAssignValueStat ::= ASSIGN valueStat {pin=1}
private varAssignPairDec ::= COMMA varAssignDec {pin=1}
varAssignDec ::= (autoType | allType) varAssignNameDec {pin=2}
varAssignNameDec ::= ID_CONTENT

// 赋值
opAssign ::= ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | MUL_ASSIGN | QUOTIENT_ASSIGN | REMAINDER_ASSIGN
opAssignExpr ::= propertyValue ((COMMA propertyValue)* opAssignValueStat)? SEMI {pin=1}
private opAssignValueStat ::= opAssign valueStat {pin=1}

// 调用表达式
propertyValueExpr ::= propertyValue SEMI {pin=1}

// 单目运算表达式
op1Expr ::= op1 valueStat SEMI {pin=1}

// nsend
nsendExpr ::= nsend LPAREN (valueStat (COMMA valueStat)*)? RPAREN SEMI {pin=1}

// throw
throwExpr ::= throw LPAREN (valueStat (COMMA valueStat)*)? RPAREN SEMI {pin=1}

// assert
assertExpr ::= assert LPAREN (valueStat (COMMA valueStat)*)? RPAREN SEMI {pin=1}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 所有类型
allType ::= primitiveType | genericType | customType

// 自定义类型
customType ::= ID_CONTENT customTypeDotId? customTypeTemplate? {pin=1}
customTypeDotId ::= DOT customTypeDotIdName {pin=1}
customTypeDotIdName ::= ID_CONTENT
private customTypeTemplate ::= LESS allType customTypeTemplatePair* GREATER {pin=1}
private customTypeTemplatePair ::= COMMA allType {pin=1}

// 通用类型
genericType ::= genericListType | genericMapType | genericFunctorType
genericMapType ::= Map LESS allType COMMA allType GREATER {pin=1}
genericListType ::= List LESS allType GREATER {pin=1}
genericFunctorType ::= Functor LESS coModifier? LPAREN genericFunctorParamType? RPAREN genericFunctorReturnType? GREATER {pin=1}
genericFunctorParamType ::= allType (COMMA allType)* {pin=1}
genericFunctorReturnType ::=  COLON allType (COMMA allType)* {pin=1}

// 基本类型
primitiveType ::= bool | double | int | I64 | any | string

// 推导类型
autoType ::= auto

//复合值///////////////////////////////////////////////////////////////////
// 复合值
valueStat ::= opNewStat | op3Stat | op2Stat | op4Stat | op5Stat | op6Stat | op7Stat | op8Stat | valueFactorStat | opNewListStat | bindStat | tcallStat | ncallStat | methodParamTailDec
valueFactorStat ::= wrapValueStat | constValue | propertyValue | reflectValue

// new
opNewStat ::= new (customType | genericType) LPAREN (valueStat (COMMA valueStat)*)? RPAREN {pin=1}
// list 快捷表达式
opNewListStat ::= LBRACK (valueStat (COMMA valueStat)*)? RBRACK {pin=1}
// bind
bindStat ::= bind LPAREN (valueStat (COMMA valueStat)*)? RPAREN  {pin=1}
// tcall
tcallStat ::= tcall LPAREN (valueStat (COMMA valueStat)*)? RPAREN  {pin=1}
// ncall
ncallStat ::= ncall LPAREN (valueStat (COMMA valueStat)*)? RPAREN  {pin=1}
// 值
wrapValueStat ::= LPAREN valueStat RPAREN
// 常量值
constValue ::= true | false | STRING_CONTENT | DIGIT_CONTENT | null
// 反射机制 返回的是一个json字符串
reflectValue ::= reflect LESS customType GREATER {pin=1}
// 属性
propertyValue ::= propertyValueFirstType propertyValueSuffix*

propertyValueFirstType ::= propertyValueCustomType | propertyValueThisType | propertyValueCastType
propertyValueCastType ::= cast LESS allType GREATER LPAREN valueFactorStat RPAREN {pin=1}
propertyValueCustomType ::= ID_CONTENT
propertyValueThisType ::= this

propertyValueSuffix ::= propertyValueDotId | propertyValueBracketValue | propertyValueMethodCall
propertyValueDotId ::= DOT propertyValueDotIdName {pin=1}
propertyValueDotIdName ::= ID_CONTENT
propertyValueBracketValue ::= LBRACK valueStat RBRACK {pin=1}
propertyValueMethodCall ::= LPAREN (valueStat (COMMA valueStat)*)? RPAREN {pin=1}

// op 类型的运算，编号越大，优先级越低///////////////////////////////////////////////////

// 双目运算
op8 ::= COND_OR
op8Stat ::= valueFactorStat op8Suffix op8SuffixEx*
op8Suffix ::= op8 (valueFactorStat | op2Value) op8SuffixEe*
op8SuffixEe ::= op3Suffix | op4Suffix | op5Suffix | op6Suffix | op7Suffix
op8SuffixEx ::= op8Suffix

op7 ::= COND_AND
op7Stat ::= valueFactorStat op7Suffix op7SuffixEx*
op7Suffix ::= op7 (valueFactorStat | op2Value) op7SuffixEe*
op7SuffixEe ::= op3Suffix | op4Suffix | op5Suffix | op6Suffix
op7SuffixEx ::= op7Suffix | op8Suffix

op6 ::= LESS | LESS_OR_EQUAL | GREATER | GREATER_OR_EQUAL | EQ | NOT_EQ
op6Stat ::= valueFactorStat op6Suffix op6SuffixEx*
op6Suffix ::= op6 (valueFactorStat | op2Value) op6SuffixEe*
op6SuffixEe ::= op3Suffix | op4Suffix | op5Suffix
op6SuffixEx ::= op6Suffix | op7Suffix | op8Suffix

op5 ::= CONCAT
op5Stat ::= valueFactorStat op5Suffix op5SuffixEx*
op5Suffix ::= op5 (valueFactorStat | op2Value) op5SuffixEe*
op5SuffixEe ::= op3Suffix | op4Suffix
op5SuffixEx ::= op5Suffix | op6Suffix | op7Suffix | op8Suffix

op4 ::= PLUS | MINUS
op4Stat ::= valueFactorStat op4Suffix op4SuffixEx*
op4Suffix ::= op4 (valueFactorStat | op2Value) op4SuffixEe*
op4SuffixEe ::= op3Suffix
op4SuffixEx ::= op4Suffix | op5Suffix | op6Suffix | op7Suffix | op8Suffix

op3 ::= MUL | QUOTIENT | REMAINDER
op3Stat ::= valueFactorStat op3Suffix op3SuffixEx*
op3Suffix ::= op3 (valueFactorStat | op2Value)
op3SuffixEx ::= op3Suffix | op4Suffix | op5Suffix | op6Suffix | op7Suffix | op8Suffix

// 单目运算
op2 ::= NOT | MINUS
op2Stat ::= op2Value op2SuffixEx*
op2Value ::= op2 valueFactorStat
op2SuffixEx ::= op3Suffix | op4Suffix | op5Suffix | op6Suffix | op7Suffix | op8Suffix

// 优先级1 前缀自加，前缀自减 从右到左
op1 ::= PLUS_PLUS | MINUS_MINUS
