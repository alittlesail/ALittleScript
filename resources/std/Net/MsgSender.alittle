
namespace ALittle;

// 长连接所有的对象集合，提供客户端使用
private Map<int, IMsgCommon> __MsgSenderMap = new Map<int, IMsgCommon>();
public static FindMsgSender(int id) : IMsgCommon { return __MsgSenderMap[id]; }

// 用于长连接
public class MsgSenderTemplate<MI : IMsgCommonNative> : IMsgCommon
{
    private int _heartbeat;                 // 心跳间隔时间
    private LoopFunction _heartbeat_loop;   //
    private bool _check_heartbeat;
    private Functor<()> _callback;

    private string _ip;
    private int _port;

    // @param heartbeat 心跳间隔时间(秒)
    // @param check_heartbeat 检测心跳是否有接受到回复
    // @param callback 断开连接的回调
    public Ctor(int heartbeat, bool check_heartbeat, Functor<()> callback)
    {
        // 创建客户端对象
        this._interface = new MI();
        this._write_factory = new lua.MessageWriteFactory();
        // 定时心跳
        this._heartbeat = heartbeat;
        this._heartbeat_loop = null;

        this._check_heartbeat = null;
        if (this._heartbeat != null)
            this._check_heartbeat = check_heartbeat;
        this._last_recv_time = 0;

        // 连接回调
        this._callback = callback;
    }

    // 连接ip对象，ip也可以是域名
    public await fun Connect(string ip, int port) : string
    {
        auto co = lua.coroutine.running();
        if (co == null)
            return "当前不是协程";

        this._co = co;
        // 注册到MsgSystem
        __MsgSenderMap[this._interface.GetID()] = this;

        this._ip = ip;
        this._port = port;
        // 开始连接
        this._interface.Connect(ip, port);

        // 协程挂起，并等待返回值
        return yield;
    }

    // 客户端连接服务端，成功
    protected fun HandleConnectSucceed()
    {
        // 初始化标记时间
        this._last_recv_time = 0;
        // 立刻发送一个心跳包，这样服务器可以很好的分辨出WebSocket
        this.SendHeartbeat();
        // 启动定时心跳
        this.StartHeartbeat();

        // 返回协程
        auto result, string reason = lua.coroutine.resume(this._co, null);
        if (result != true) Error(reason);
    }

    // 断开连接
    protected fun HandleDisconnect()
    {
        this.StopHeartbeat();
        __MsgSenderMap[this._interface.GetID()] = null;

        this.ClearRPC("连接断开了");
        if (this._callback != null)
            this._callback();
    }

    // 客户端链接服务端，失败
    protected fun HandleConnectFailed(string error)
    {
        // 返回协程
        __MsgSenderMap[this._interface.GetID()] = null;
        if (error == null) error = this._ip..":"..this._port.."连接失败";
        auto result, string reason = lua.coroutine.resume(this._co, error);
        if (result != true) Error(reason);
    }

    // 关闭连接
    public fun Close(string reason)
    {
        // 停止发送心跳包
        this.StopHeartbeat();
        // 关闭连接
        this._interface.Close();

        // 清理RPC
        if (reason == null) reason = "主动关闭连接";
        this.ClearRPC(reason);

        __MsgSenderMap[this._interface.GetID()] = null;
    }

    // 发送心跳包
    // max_ms 可以接受的最大延迟毫秒数，默认是10000毫秒
    private fun SendHeartbeat(int max_ms)
    {
        // 如果没有连接成功，那么直接返回
        if (this._interface.IsConnected() == false)
            return;

        // 发送心跳包
        this._write_factory.ResetOffset();
        // 设置id
        this._write_factory.SetID(0);
        this._write_factory.SetRpcID(0);
        this._interface.SendFactory(this._write_factory);

        // 启动检测
        if (this._check_heartbeat)
        {
            // 获取当前时间
            int send_time = lua.os.clock();
            // 计算合适的间隔时间
            double default_delta = this._heartbeat / 2;

            double delta_time = max_ms;
            if (delta_time == null) delta_time = default_delta;
            if (delta_time > default_delta)
            delta_time = default_delta;
            // 定时检查
            LoopFunction check_loop = new LoopFunction(bind(this.CheckHeartbeat, this, send_time, lua.math.floor(delta_time), lua.math.floor(delta_time)), 1, lua.math.floor(delta_time), 1);
            check_loop.Start();
        }
    }

    // 心跳包检测
    private fun CheckHeartbeat(int send_time, int cmp_time, int delta_time)
    {
        // 由得时候，以为APP被挂起，所有线程无条件挂起，导致LoopSystem时间跳跃。会立即执行当前的回调函数
        // 所以确认当前时间和发送时间是否在delta_time范围内，否则必须重新创建一个LoopFunction

        // 获取当前时间
        int invoke_time = lua.os.time();
        // 计算真实的间隔时间
        int interval = invoke_time - send_time;
        // 如果真实的间隔时间，小于制定的间隔时间，那么重新创建一个LoopFunction
        if (delta_time > interval)
        {
            // 减少间隔时间
            delta_time = delta_time - interval;
            LoopFunction check_loop = new LoopFunction(bind(this.CheckHeartbeat, this, send_time*1000, cmp_time, delta_time), 1, delta_time, 1);
            A_WeakLoopSystem.AddUpdater(check_loop);
            return;
        }
        // 如果当前毫秒数 减去 最后一次接受数据包的毫秒数，超过指定范围
        // 那么就表示连接已经断了
        if (this._last_recv_time > 0 && send_time - this._last_recv_time > cmp_time)
        {
            // 如果没有连接成功，那么直接返回
            if (this._interface.IsConnected() == false)
            return;
            // 主动关闭连接
            this.Close("心跳检测失败，主动断开连接");
            // 调用断开连接回调
            if (this._callback != null)
                this._callback();
        }
    }

    // 开始发送心跳包
    private fun StartHeartbeat()
    {
        if (this._heartbeat == null)
            return;
        if (this._heartbeat <= 0)
            return;
        if (this._heartbeat_loop != null)
            return;
        this._heartbeat_loop = new LoopFunction(bind(this.SendHeartbeat, this, null), -1, this._heartbeat * 1000, 1);
        this._heartbeat_loop.Start();
    }
    // 停止发送心跳包
    private fun StopHeartbeat()
    {
        if (this._heartbeat_loop == null)
            return;
        this._last_recv_time = 0;
        this._heartbeat_loop.Close();
        this._heartbeat_loop = null;
    }
}
