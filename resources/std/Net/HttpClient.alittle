namespace ALittle;

// Http协议接口类，负责处理
public class IHttpClient
{
    // 提供子类继承
    protected await fun SendRPC(string method, any content) : string, any {}

    // 提供框架调用
    protected await static Invoke(string method, IHttpClient client, any content) : string, any { return client.SendRPC(method, content); }
}

//客户端部分//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 连接对象
public class IHttpInterface
{
    public fun GetID() : int {}
    public fun SetURL(string url, string content) {}
    public fun Start() {}
    public fun Stop() {}
    public fun GetResponse() : string {}
}

// 短连接所有的对象集合，提供客户端使用
private Map<int, IHttpClient> __HttpClientMap = new Map<int, IHttpClient>();
public static FindHttpClient(int id) : IHttpClient { return __HttpClientMap[id]; }

public class HttpClient<HC : IHttpInterface> : public IHttpClient
{
    private HC _interface;
    private thread _co;
    private string _ip;
    private int _port;

    public Ctor(string ip, int port)
    {
        this._interface = new HC();
        this._ip = ip;
        this._port = port;
    }

    protected await fun SendRPC(string method, any content) : string, any
    {
        thread co = coroutine.running();
        if (co == null)
            return "当前不是协程", null;

        this._co = co;
        __HttpClientMap[this._interface.GetID()] = this;

        string url = "http://"..this._ip..":"..this._port.."/"..method;
        if (content == null)
            this._interface.SetURL(url, null);
        else
            this._interface.SetURL(url, lua.json.encode(content));
        this._interface.Start();

        // 协程挂起，并等待返回值
        return yield;
    }

    public fun Stop()
    {
        this._interface.Stop();
    }

    public fun HandleSucceed()
    {
        __HttpClientMap[this._interface.GetID()] = null;
        auto error, Map<string, any> param = pcall(lua.json.decode, this._interface.GetResponse());
        if (error != null)
        {
            assert(coroutine.resume(this._co, error, null));
            return;
        }
        if (param["error"] != null)
        {
            assert(coroutine.resume(this._co, param["error"], null));
            return;
        }
        assert(coroutine.resume(this._co, null, param));
    }

    public fun HandleFailed(string reason)
    {
        __HttpClientMap[this._interface.GetID()] = null;
        assert(coroutine.resume(this._co, reason, null));
    }
}

//服务器部分//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

private auto __all_callback = new Map<string, Functor<await(IHttpClient, any):any>>();
table.setweak(__all_callback, false, true);
protected static RegHttpCallback(string method, Functor<await(IHttpClient, any):any> callback)
{
    if (__all_callback[method] != null)
    {
        Error("RegHttpCallback消息回调函数注册失败，名字为"..method.."已存在");
        return;
    }
    __all_callback[method] = callback;
}
// 获取回调函数
public static FindHttpCallback(string method) : Functor<await(IHttpClient, any):any>
{
    return __all_callback[method];
}

private auto __all_download_callback = new Map<string, Functor<await(IHttpClient, any):string, int>>();
table.setweak(__all_download_callback, false, true);
protected static RegHttpDownloadCallback(string method, Functor<await(IHttpClient, any):string, int> callback)
{
    if (__all_download_callback[method] != null)
    {
        Error("RegHttpDownloadCallback消息回调函数注册失败，名字为"..method.."已存在");
        return;
    }
    __all_download_callback[method] = callback;
}
// 获取回调函数
public static FindHttpDownloadCallback(string method) : Functor<await(IHttpClient, any):string, int>
{
    return __all_download_callback[method];
}