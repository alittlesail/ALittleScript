
namespace ALittle;

private auto __all_callback = new Map<int, Functor<(IMsgCommon, any)>>();
Setweak(__all_callback, false, true);
protected static RegMsgCallback(int msg_id, Functor<(IMsgCommon, any)> callback)
{
    if (__all_callback[msg_id] != null)
    {
        Error("RegMsgCallback消息回调函数注册失败，名字为"..msg_id.."已存在");
        return;
    }
    __all_callback[msg_id] = callback;
}
// 获取回调函数
public static FindMsgCallback(int msg_id) : Functor<(IMsgCommon, any)>
{
    return __all_callback[msg_id];
}

// 注册回调函数
private auto __all_rpc_callback = new Map<int, Functor<await(IMsgCommon, any): any>>();
private auto __all_rpc_return_id = new Map<int, int>();
Setweak(__all_rpc_callback, false, true);
protected static RegMsgRpcCallback(int msg_id, Functor<await(IMsgCommon, any) : any> callback, int return_id)
{
    if (__all_rpc_callback[msg_id] != null)
    {
        Error("RegMsgRpcCallback消息回调函数注册失败，名字为"..msg_id.."已存在");
        return;
    }
    __all_rpc_callback[msg_id] = callback;
    __all_rpc_return_id[msg_id] = return_id;
}
// 获取回调函数
public static FindMsgRpcCallback(int msg_id) : Functor<await(IMsgCommon, any) : any>, int
{
    return __all_rpc_callback[msg_id], __all_rpc_return_id[msg_id];
}

// 连接对象
public class IMsgCommonNative
{
    public fun SetID(int id) {}         // 设置连接对象全局ID
    public fun GetID() : int {}         // 获取连接对象全局ID
    public fun Connect(string ip, int port) {}  // 主动连接
    public fun IsConnected() : bool {}      // 是否已经连接
    public fun SendFactory(lua.MessageWriteFactory factory) {}  // 发送请求
    public fun Close() {}               // 关闭连接
}

// RPC结构信息
struct MsgRPCInfo
{
    int rpc_id;
    lua.thread co;
}

// 用于长连接
public class IMsgCommon
{
    private IMsgCommonNative _interface;      // 网络对象
    private lua.MessageWriteFactory _write_factory;     // 协议序列化对象
    private Map<int, ProtocolInvokeInfo> _invoke_map;// 协议缓存数据

    private int _last_recv_time;
    private SafeIDCreator _id_creator;
    private Map<int, MsgRPCInfo> _id_map_rpc;
    private lua.thread _co;

    // @param heartbeat 心跳间隔时间(秒)
    // @param check_heartbeat 检测心跳是否有接受到回复
    // @param callback 断开连接的回调
    public Ctor()
    {
        this._invoke_map = new Map<int, ProtocolInvokeInfo>();
        this._last_recv_time = 0;

        this._id_creator = new SafeIDCreator();
        this._id_map_rpc = new Map<int, MsgRPCInfo>();
    }

    // 获取ID
    public fun GetID() : int { return this._interface.GetID(); }

    // 判断是否已经连接成功
    public fun IsConnected() : bool
    {
        return this._interface.IsConnected();
    }

    // 消息读取
    private fun MessageRead(lua.MessageReadFactory factory, int msg_id) : any
    {
        auto info = this._invoke_map[msg_id];
        if (info == null)
        {
            auto error, auto invoke_info = tcall(CreateProtocolInvokeInfo, msg_id);
            if (error != null)
            {
                Error(error);
                return null;
            }
            info = invoke_info;
            this._invoke_map[msg_id] = info;
        }
        return PS_ReadMessageForReceive(factory, info, factory.GetTotalSize());
    }

    // 序列化
    public fun MessageWrite(int msg_id, any msg_body)
    {
        auto info = this._invoke_map[msg_id];
        if (info == null)
        {
            auto error, auto invoke_info = tcall(CreateProtocolInvokeInfo, msg_id);
            if (error != null)
            {
                Error(error);
                return;
            }
            info = invoke_info;
            this._invoke_map[msg_id] = info;
        }
        this._write_factory.ResetOffset();
        PS_WriteMessageForSend(this._write_factory, info, msg_body);
        this._write_factory.SetID(msg_id);
    }

    // 收到服务端发来的数据包
    public fun HandleMessage(int id, int rpc_id, lua.MessageReadFactory factory)
    {
        // 消息id为0，心跳包返回
        if (id == 0)
        {
            // 记录最后接受时间
            this._last_recv_time = lua.os.clock();
            return;
        }

        // 如果是普通消息
        if (rpc_id == 0)
        {
            // 获取函数对象
            auto callback = FindMsgCallback(id);
            if (callback == null)
            {
                Log("MsgSystem.HandleMessage can't find callback by id:" .. id);
                return;
            }

            any msg = this.MessageRead(factory, id);
            if (msg == null)
            {
                Log("MsgSystem.HandleMessage MessageRead failed by id:" .. id);
                return;
            }
            callback(this, msg);
            return;
        }

        // 如果rpc_id大于0，说明是对方发过来
        if (rpc_id > 0)
        {
            this.HandleRPCRequest(id, rpc_id, factory);
            return;
        }

        // 如果rpc_id小于0，说明是RPC回包
        rpc_id = -rpc_id;
        // 回收id
        this._id_creator.ReleaseID(rpc_id);
        MsgRPCInfo info = this._id_map_rpc[rpc_id];
        if (info == null)
        {
            Log("MsgSystem.HandleMessage can't find rpc info by id:"..id);
            return;
        }
        this._id_map_rpc[rpc_id] = null;

        // 如果是RPC异常包
        if (id == 1)
        {
            auto result, auto reason = lua.coroutine.resume(info.co, factory.ReadString());
            if (result != true) Error(reason);
            return;
        }

        any msg = this.MessageRead(factory, id);
        if (msg == null)
        {
            auto result, auto reason = lua.coroutine.resume(info.co, "MsgSystem.HandleMessage MessageRead failed by id:"..id);
            if (result != true) Error(reason);
            Log("MsgSystem.HandleMessage MessageRead failed by id:"..id);
            return;
        }
        auto result, auto reason = lua.coroutine.resume(info.co, null, msg);
        if (result != true) Error(reason);
    }

    // 发送数据包
    public fun Send(int msg_id, any msg_body, int rpc_id)
    {
        if (!this.IsConnected()) return;

        this._write_factory.SetRpcID(rpc_id);
        this.MessageWrite(msg_id, msg_body);
        this._interface.SendFactory(this._write_factory);
    }

    // 发送RPC异常包
    public fun SendRpcError(int rpc_id, string reason)
    {
        // 如果没有连接成功，那么直接返回
        if (!this.IsConnected()) return;

        // 发送心跳包
        this._write_factory.ResetOffset();
        // 设置id
        this._write_factory.SetID(1);
        this._write_factory.SetRpcID(-rpc_id);
        this._write_factory.WriteString(reason);
        this._interface.SendFactory(this._write_factory);
    }

    // 发送RPC包
    public await fun SendRPC(int msg_id, any msg_body) : string, any
    {
        auto co = lua.coroutine.running();
        if (co == null)
            return "当前不是协程", null;

        if (!this.IsConnected())
            return "连接还没成功", null;

        int rpc_id = this._id_creator.CreateID();
        this._write_factory.SetRpcID(rpc_id);
        this.MessageWrite(msg_id, msg_body);
        this._interface.SendFactory(this._write_factory);

        auto info = new MsgRPCInfo();
        info.co = co;
        info.rpc_id = rpc_id;
        this._id_map_rpc[rpc_id] = info;
        // 协程挂起，并等待返回值
        return yield;
    }

    // 处理RPC请求
    private async fun HandleRPCRequest(int id, int rpc_id, lua.MessageReadFactory factory)
    {
        // 获取函数对象
        auto callback, int return_id = FindMsgRpcCallback(id);
        if (callback == null)
        {
            this.SendRpcError(rpc_id, "没有注册消息RPC回调函数");
            Log("MsgSystem.HandleMessage can't find callback by id:"..id);
            return;
        }

        any msg = this.MessageRead(factory, id);
        if (msg == null)
        {
            this.SendRpcError(rpc_id, "MsgSystem.HandleMessage MessageRead failed by id:"..id);
            Log("MsgSystem.HandleMessage MessageRead failed by id:"..id);
            return;
        }

        // 调用函数
        auto error, any return_body = tcall(callback, this, msg);
        if (error != null)
        {
            this.SendRpcError(rpc_id, error);
            Log("MsgSystem.HandleMessage callback invoke failed! by id:"..id..", reason:"..error);
            return;
        }
        if (return_body == null)
        {
            this.SendRpcError(rpc_id, "MsgSystem.HandleMessage callback have not return! by id:"..id);
            Log("MsgSystem.HandleMessage callback have not return! by id:"..id);
            return;
        }
        this.Send(return_id, return_body, -rpc_id);
    }

    // 清理RPC
    public fun ClearRPC(string reason)
    {
        // 先复制，再清理
        auto tmp = new Map<int, MsgRPCInfo>();
        for (auto rpc_id, auto info in this._id_map_rpc)
        {
            this._id_creator.ReleaseID(rpc_id);
            tmp[rpc_id] = info;
        }
        this._id_map_rpc = new Map<int, MsgRPCInfo>();
        // 逐个调用表示失败
        for (auto rpc_id, auto info in tmp)
        {
            auto result, auto reason = lua.coroutine.resume(info.co, reason, null);
            if (result != true) Error(reason);
        }
    }

    public fun Close(string reason)
    {
        if (reason == null) reason = "主动关闭连接";
        this.ClearRPC(reason);
        this._interface.Close();
    }

    // 提供框架调用
    protected static Invoke(int msg_id, IMsgCommon client, any msg_body) { client.Send(msg_id, msg_body, 0); }
    protected await static InvokeRPC(int msg_id, IMsgCommon client, any msg_body) : string, any { return client.SendRPC(msg_id, msg_body); }
}
