
namespace ALittle;

// 二进制协议接口类
public class INetClient
{
    public fun Send(int msg_id, any msg_body, int rpc_id) {}
    public await fun SendRPC(int msg_id, any msg_body) : string, any {}
}

// 连接对象
public class INetInterface
{
    public fun GetID() : int {}
    public fun Connect(string ip, int port) {}
    public fun IsConnected() : bool {}
    public fun SendFactory(IMessageWriteFactory factory) {}
    public fun Close() {}
}

// RPC结构信息
struct NetClientRPCInfo
{
    int rpc_id;
    thread co;
}

// 长连接所有的对象集合
private Map<int, INetClient> __NetClientMap = new Map<int, INetClient>();
public static FindNetClient(int id) : INetClient { return __NetClientMap[id]; }

// 用于长连接
public class NetClient<NI : INetInterface, MWF : IMessageWriteFactory> : public INetClient
{
    private NI _net_interface;      // 网络对象
    private MWF _write_factory;     // 协议序列化对象
    private Map<int, ProtocolInvokeInfo> _invoke_map;// 协议缓存数据

    private int _heartbeat;                 // 心跳间隔时间
    private LoopFunction _heartbeat_loop;   //
    private bool _check_heartbeat;
    private int _last_recv_time;
    private SafeIDCreator _id_creator;
    private Map<int, NetClientRPCInfo> _id_map_rpc;

    private Functor<(INetClient)> _net_connect_succeed_callback;
    private Functor<(INetClient)> _net_connect_failed_callback;
    private Functor<(INetClient)> _net_disconnected_callback;

    // @param protocol 协议对象
    // @param heartbeat 心跳间隔时间(秒)
    // @param check_heartbeat 检测心跳是否有接受到回复
    public Ctor(INetInterface net_interface, IMessageWriteFactory factory, int heartbeat, bool check_heartbeat)
    {
        // 创建客户端对象
        this._net_interface = new NI();
        this._write_factory = new MWF();
        // 定时心跳
        this._heartbeat = heartbeat;
        this._heartbeat_loop = null;

        this._check_heartbeat = null;
        if (this._heartbeat != null)
            this._check_heartbeat = check_heartbeat;
        this._last_recv_time = 0;

        this._id_creator = new SafeIDCreator();
        this._id_map_rpc = new Map<int, NetClientRPCInfo>();

        // 连接回调
        this._net_connect_succeed_callback = null;
        this._net_connect_failed_callback = null;
        this._net_disconnected_callback = null;
    }

    public set net_connect_succeed_callback(Functor<(INetClient)> value)
    {
        this._net_connect_succeed_callback = value;
    }
    public set net_connect_failed_callback(Functor<(INetClient)> value)
    {
        this._net_connect_failed_callback = value;
    }
    public set net_disconnected_callback(Functor<(INetClient)> value)
    {
        this._net_disconnected_callback = value;
    }

    // 连接ip对象，ip也可以是域名
    public fun Connect(string ip, int port)
    {
        // 开始连接
        this._net_interface.Connect(ip, port);
        // 注册到NetSystem
        __NetClientMap[this._net_interface.GetID()] = this;
    }

    // 判断是否已经连接成功
    public fun IsConnected() : bool
    {
        return this._net_interface.IsConnected();
    }

    // 客户端连接服务端，成功
    public fun HandleConnectSucceed()
    {
        // 初始化标记时间
        this._last_recv_time = 0;
        // 立刻发送一个心跳包，这样服务器可以很好的分辨出WebSocket
        this.SendHeartbeat();
        // 启动定时心跳
        this.StartHeartbeat();
        // 通知逻辑
        if (this._net_connect_succeed_callback != null)
            this._net_connect_succeed_callback(this);
    }

    // 断开连接
    public fun HandleDisconnect()
    {
        this.StopHeartbeat();
        __NetClientMap[this._net_interface.GetID()] = null;

        this.ClearRPC("连接断开了");
        if (this._net_disconnected_callback != null)
            this._net_disconnected_callback(this);
    }

    // 客户端链接服务端，失败
    public fun HandleConnectFailed()
    {
        __NetClientMap[this._net_interface.GetID()] = null;
        if (this._net_connect_failed_callback != null)
            this._net_connect_failed_callback(this);
    }

    // 消息读取
    private fun MessageRead(IMessageReadFactory factory, int msg_id) : any
    {
        auto info = this._invoke_map[msg_id];
        if (info == null)
        {
            auto error, auto invoke_info = pcall(CreateProtocolInvokeInfo, msg_id);
            if (error != null)
            {
                Error(error);
                return null;
            }
            info = invoke_info;
            this._invoke_map[msg_id] = info;
        }
        return PS_ReadMessageForReceive(factory, info, factory.GetTotalSize());
    }

    // 序列化
    public fun MessageWrite(int msg_id, any msg_body)
    {
        auto info = this._invoke_map[msg_id];
        if (info == null)
        {
            auto error, auto invoke_info = pcall(CreateProtocolInvokeInfo, msg_id);
            if (error != null)
            {
                Error(error);
                return;
            }
            info = invoke_info;
            this._invoke_map[msg_id] = info;
        }
        this._write_factory.ResetOffset();
        PS_WriteMessageForSend(this._write_factory, info, msg_body);
        this._write_factory.SetID(msg_id);
    }

    // 收到服务端发来的数据包
    public fun HandleMessage(int id, int rpc_id, IMessageReadFactory factory)
    {
        // 消息id为0，心跳包返回
        if (id == 0)
        {
            // 记录最后接受时间
            this._last_recv_time = os.clock();
            return;
        }

        // 如果是普通消息
        if (rpc_id == 0)
        {
            // 获取函数对象
            Functor<(INetClient, any) : any> callback = FindMessageCallback(id);
            if (callback == null)
            {
                Log("NetSystem.HandleMessage can't find callback by id:" .. id);
                return;
            }

            any msg = this.MessageRead(factory, id);
            if (msg == null)
            {
                Log("NetSystem.HandleMessage MessageRead failed by id:" .. id);
                return;
            }
            callback(this, msg);
            return;
        }

        // 如果rpc_id大于0，说明是对方发过来
        if (rpc_id > 0)
        {
            // 获取函数对象
            Functor<(INetClient, any) : any> callback, int return_id = FindMessageCallback(id);
            if (callback == null)
            {
                this.SendRpcError(-rpc_id, "没有注册消息RPC回调函数");
                Log("NetSystem.HandleMessage can't find callback by id:"..id);
                return;
            }

            any msg = this.MessageRead(factory, id);
            if (msg == null)
            {
                Log("NetSystem.HandleMessage MessageRead failed by id:"..id);
                return;
            }

            // 调用函数
            auto error, any return_body = pcall(callback, this, msg);
            if (error != true)
            {
                this.SendRpcError(-rpc_id, return_body);
                Log("NetSystem.HandleMessage callback invoke failed! by id:"..id..", reason:"..error);
                return;
            }
            this.Send(return_id, return_body, -rpc_id);
            return;
        }

        // 如果rpc_id小于0，说明是RPC回包
        rpc_id = -rpc_id;
        // 回收id
        this._id_creator.ReleaseID(rpc_id);
        NetClientRPCInfo info = this._id_map_rpc[rpc_id];
        if (info == null)
        {
            Log("NetSystem.HandleMessage can't find rpc info by id:"..id);
            return;
        }
        this._id_map_rpc[rpc_id] = null;

        // 如果是RPC异常包
        if (id == 1)
        {
            coroutine.resume(info.co, factory.ReadString());
            return;
        }

        any msg = this.MessageRead(factory, id);
        if (msg == null)
        {
            Log("NetSystem.HandleMessage MessageRead failed by id:"..id);
            return;
        }
        coroutine.resume(info.co, null, msg);
    }

    // 发送数据包
    public fun Send(int msg_id, any msg_body, int rpc_id)
    {
        this._write_factory.SetRpcID(rpc_id);
        this.MessageWrite(msg_id, msg_body);
        this._net_interface.SendFactory(this._write_factory);
    }

    // 关闭连接
    public fun Close(string reason)
    {
        // 停止发送心跳包
        this.StopHeartbeat();
        // 关闭连接
        this._net_interface.Close();

        // 清理RPC
        if (reason == null) reason = "主动关闭连接";
        this.ClearRPC(reason);

        __NetClientMap[this._net_interface.GetID()] = null;
    }

    // 发送心跳包
    // max_ms 可以接受的最大延迟毫秒数，默认是10000毫秒
    public fun SendHeartbeat(int max_ms)
    {
        // 如果没有连接成功，那么直接返回
        if (this._net_interface.IsConnected() == false)
            return;

        // 发送心跳包
        this._write_factory.ResetOffset();
        // 设置id
        this._write_factory.SetID(0);
        this._write_factory.SetRpcID(0);
        this._net_interface.SendFactory(this._write_factory);

        // 启动检测
        if (this._check_heartbeat)
        {
            // 获取当前时间
            int send_time = os.clock();
            // 计算合适的间隔时间
            double default_delta = this._heartbeat / 2;

            double delta_time = max_ms;
            if (delta_time == null) delta_time = default_delta;
            if (delta_time > default_delta)
            delta_time = default_delta;
            // 定时检查
            LoopFunction check_loop = new LoopFunction(bind(this.CheckHeartbeat, this, send_time, math.floor(delta_time), math.floor(delta_time)), 1, math.floor(delta_time), 1);
            check_loop.Start();
        }
    }

    // 发送RPC异常包
    public fun SendRpcError(int rpc_id, string reason)
    {
        // 如果没有连接成功，那么直接返回
        if (this._net_interface.IsConnected() == false)
            return;

        // 发送心跳包
        this._write_factory.ResetOffset();
        // 设置id
        this._write_factory.SetID(1);
        this._write_factory.SetRpcID(rpc_id);
        this._write_factory.WriteString(reason);
        this._net_interface.SendFactory(this._write_factory);
    }

    // 心跳包检测
    public fun CheckHeartbeat(int send_time, int cmp_time, int delta_time)
    {
        // 由得时候，以为APP被挂起，所有线程无条件挂起，导致LoopSystem时间跳跃。会立即执行当前的回调函数
        // 所以确认当前时间和发送时间是否在delta_time范围内，否则必须重新创建一个LoopFunction

        // 获取当前时间
        int invoke_time = os.time();
        // 计算真实的间隔时间
        int interval = invoke_time - send_time;
        // 如果真实的间隔时间，小于制定的间隔时间，那么重新创建一个LoopFunction
        if (delta_time > interval)
        {
            // 减少间隔时间
            delta_time = delta_time - interval;
            LoopFunction check_loop = new LoopFunction(bind(this.CheckHeartbeat, this, send_time*1000, cmp_time, delta_time), 1, delta_time, 1);
            A_WeakLoopSystem.AddUpdater(check_loop);
            return;
        }
        // 如果当前毫秒数 减去 最后一次接受数据包的毫秒数，超过指定范围
        // 那么就表示连接已经断了
        if (this._last_recv_time > 0 && send_time - this._last_recv_time > cmp_time)
        {
            // 如果没有连接成功，那么直接返回
            if (this._net_interface.IsConnected() == false)
            return;
            // 主动关闭连接
            this.Close("心跳检测失败，主动断开连接");
            // 调用断开连接回调
            if (this._net_disconnected_callback != null)
            this._net_disconnected_callback(this);
        }
    }

    // 发送RPC包
    public await fun SendRPC(int msg_id, any msg_body) : string, any
    {
        thread co = coroutine.running();
        if (co == null)
            return "当前不是协程", null;

        if (!this.IsConnected())
            return "连接还没成功", null;

        int rpc_id = this._id_creator.CreateID();
        this._write_factory.SetRpcID(rpc_id);
        this.MessageWrite(msg_id, msg_body);
        this._net_interface.SendFactory(this._write_factory);

        NetClientRPCInfo info = new NetClientRPCInfo();
        info.co = co;
        info.rpc_id = rpc_id;
        this._id_map_rpc[rpc_id] = info;
        // 协程挂起，并等待返回值
        return yield;
    }

    // 处理RPC应答
    public fun HandleRPCMessage(int rpc_id, string error, any param)
    {
        NetClientRPCInfo info = this._id_map_rpc[rpc_id];
        if (info == null)
        {
            Error("出现未知的rpc_id.", rpc_id);
            return;
        }
        this._id_creator.ReleaseID(rpc_id);

        this._id_map_rpc[rpc_id] = null;
        assert(coroutine.resume(info.co, error, param));
    }

    // 清理RPC
    public fun ClearRPC(string reason)
    {
        // 先复制，再清理
        Map<int, NetClientRPCInfo> tmp = new Map<int, NetClientRPCInfo>();
        for (int rpc_id, NetClientRPCInfo info in this._id_map_rpc)
        {
            this._id_creator.ReleaseID(rpc_id);
            tmp[rpc_id] = info;
        }
        this._id_map_rpc = new Map<int, NetClientRPCInfo>();
        // 逐个调用表示失败
        for (int rpc_id, NetClientRPCInfo info in tmp)
        {
            auto result, auto reason = coroutine.resume(info.co, reason, null);
            if (result != true) Error(reason);
        }
    }

    // 开始发送心跳包
    public fun StartHeartbeat()
    {
        if (this._heartbeat == null)
            return;
        if (this._heartbeat <= 0)
            return;
        if (this._heartbeat_loop != null)
            return;
        this._heartbeat_loop = new LoopFunction(bind(this.SendHeartbeat, this, null), -1, this._heartbeat, 1);
        this._heartbeat_loop.Start();
    }
    // 停止发送心跳包
    public fun StopHeartbeat()
    {
        if (this._heartbeat_loop == null)
            return;
        this._last_recv_time = 0;
        this._heartbeat_loop.Close();
        this._heartbeat_loop = null;
    }
}
