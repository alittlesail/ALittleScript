
namespace ALittle;

protected class CSVConfig
{
    protected ICSVFile _csv_file;
    protected StructInfo _reflect_info;
    protected CSVInvokeInfo _csv_info;

    public fun Init(ICSVFile loader)
    {
        this._csv_file = loader;
    }

    public fun GetFieldInfo(string field) : int, bool
    {
        int field_index = 0;
        bool is_number = false;
        for (int index, auto name in this._reflect_info.name_list)
        {
            if (name == field)
            {
                field_index = index;
                auto var_type = this._reflect_info.type_list[index];
                is_number = var_type == "int" || var_type == "double" || var_type == "I64";
                break;
            }
        }
        return field_index, is_number;
    }

    public fun GetFieldNameList() : List<string>
    {
        return this._reflect_info.name_list;
    }

    public fun ReadCell(int lua_row, int lua_col) : string
    {
        return this._csv_file.ReadCell(lua_row, lua_col);
    }

    private fun LoadCell<T>(int row) : T
    {
        Map<string, any> value = new Map<string, any>();
        for (int index, auto handle in this._csv_info.handle)
        {
            value[handle.var_name] = handle.func(this._csv_file.ReadCell(row, index), handle);
        }
        return cast<T>(value);
    }
}

class KeyValueConfig
{
    private Map<string, string> _data;

    public Ctor()
    {
        this._data = new Map<string, string>();
    }

    public fun Init(ICSVFile loader)
    {
        this._data = new Map<string, string>();
        if (loader == null) return;

        int row_count = loader.GetRowCount();
        for (int row = 1, row_count, 1)
        {
            string key = loader.ReadCell( row, 1);
            string value = loader.ReadCell(row, 2);
            if (key != null && value != null)
                this._data[key] = value;
        }
        loader.Close();
    }

    public fun GetString(string key, string default) : string
    {
        string value = this._data[key];
        if (value == null) return default;
        return value;
    }

    public fun GetInt(string key, int default) : int
    {
        string value = this._data[key];
        if (value == null) return default;
        if (value == "") return 0;
        return lua.math.floor(lua.tonumber(value));
    }

    public fun GetDouble(string key, double default) : double
    {
        string value = this._data[key];
        if (value == null) return default;
        if (value == "") return 0;
        return lua.tonumber(value);
    }

    public fun GetIntList(string key, List<int> default) : List<int>
    {
        string value = this._data[key];
        if (value == null) return default;
        auto list = String_Split(value, __split_list_last);
        List<int> int_list = new List<int>();
        for (auto index, auto v in list)
        {
            if (v == "") int_list[index] = 0;
            else int_list[index] = lua.math.floor(lua.tonumber(v));
        }
        return int_list;
    }

    public fun GetDoubleList(string key, List<double> default) : List<double>
    {
        string value = this._data[key];
        if (value == null) return default;
        auto list = String_Split(value, __split_list_last);
        List<double> double_list = new List<double>();
        for (auto index, auto v in list)
        {
            if (v == "") double_list[index] = 0;
            else double_list[index] = lua.tonumber(v);
        }
        return double_list;
    }

    public fun GetStringList(string key, List<string> default) : List<string>
    {
        string value = this._data[key];
        if (value == null) return default;
        return String_Split(value, __split_list_last);
    }
}

class SingleKeyTableConfig<KEY, T : struct> : CSVConfig
{
    private Map<KEY, int> _key_map;
    private Map<KEY, T> _cache_map;

    public Ctor()
    {
        this._reflect_info = reflect<T>;
        this._key_map = new Map<KEY, int>();
        this._cache_map = new Map<KEY, T>();
        Setweak(this._cache_map, false, true);
    }

    public get key_map() : Map<KEY, int> { return this._key_map; }

    public fun Init(ICSVFile loader)
    {
        if (this._csv_file != null) this._csv_file.Close();
        this._csv_file = loader;
        if (this._csv_file == null) return;

        string key_type = this._reflect_info.name_list[1];
        bool is_number = key_type == "int" || key_type == "double" || key_type == "I64";

        int row_count = this._csv_file.GetRowCount();
        for (int row = 1, row_count, 1)
        {
            string value = this._csv_file.ReadCell(row, 1);
            if (value != null)
            {
                if (is_number)
                    this._key_map[cast<KEY>(lua.tonumber(value))] = row;
                else
                    this._key_map[cast<KEY>(value)] = row;
            }
        }
    }

    public fun GetData(KEY key) : T
    {
        if (this._csv_file == null) return null;

        T value = this._cache_map[key];
        if (value != null) return value;

        int row = this._key_map[key];
        if (row == null) return null;

        value = this.LoadCell<T>(row);
        if (value == null) return null;

        this._cache_map[key] = value;
        return value;
    }

    public fun CreateIndex<INDEX>(string field) : SingleKeyTableIndexConfig<INDEX, KEY, T>
    {
        if (this._csv_file == null) return null;

        int col_index, bool is_number = this.GetFieldInfo(field);
        if (col_index == 0) return null;

        return new SingleKeyTableIndexConfig<INDEX, KEY, T>(this, col_index, is_number);
    }
}

class SingleKeyTableIndexConfig<INDEX, KEY, T : struct>
{
    private SingleKeyTableConfig<KEY, T> _parent;
    private Map<INDEX, Map<KEY, bool>> _value_map;

    public Ctor(SingleKeyTableConfig<KEY, T> parent, int col_index, bool is_number)
    {
        this._parent = parent;
        this._value_map = new Map<INDEX, Map<KEY, bool>>();

        for (auto key, int row in this._parent.key_map)
        {
            INDEX value;
            if (is_number)
                value = cast<INDEX>(lua.tonumber(this._parent.ReadCell(row, col_index)));
            else
                value = cast<INDEX>(this._parent.ReadCell(row, col_index));

            auto key_set = this._value_map[value];
            if (key_set == null)
            {
                key_set = new Map<KEY, bool>();
                this._value_map[value] = key_set;
            }
            key_set[key] = true;
        }
    }

    public fun GetKeySet(INDEX index) : Map<KEY, bool>
    {
        return this._value_map[index];
    }

    public fun GetOne(INDEX index) : T
    {
        auto keys = this._value_map[index];
        if (keys == null) return null;
        for (auto k, auto _ in keys)
            return this._parent.GetData(k);
    }

    public fun GetList(INDEX index) : List<T>
    {
        auto list = new List<T>();
        auto keys = this._value_map[index];
        if (keys == null) return list;

        auto count = 0;
        for (auto k, auto _ in keys)
        {
            ++ count;
            list[count] = this._parent.GetData(k);
        }
        return list;
    }
}

class DoubleKeyTableConfig<KEY1, KEY2, T : struct> : CSVConfig
{
    private Map<KEY1, Map<KEY2, int>> _key_map;
    private Map<KEY1, Map<KEY2, T>> _cache_map;

    public Ctor()
    {
        this._reflect_info = reflect<T>;
        this._key_map = new Map<KEY1, Map<KEY2, int>>();
        this._cache_map = new Map<KEY1, Map<KEY2, T>>();
        Setweak(this._cache_map, false, true);
    }

    public fun Init(ICSVFile loader)
    {
        if (this._csv_file != null) this._csv_file.Close();
        this._csv_file = loader;
        if (this._csv_file == null) return;

        string first_key_type = this._reflect_info.name_list[1];
        bool first_is_number = first_key_type == "int" || first_key_type == "double" || first_key_type == "I64";
        string second_key_type = this._reflect_info.name_list[2];
        bool second_is_number = second_key_type == "int" || second_key_type == "double" || second_key_type == "I64";

        int row_count = this._csv_file.GetRowCount();
        for (int row = 1, row_count, 1)
        {
            Map<KEY2, int> tmp;
            string value = this._csv_file.ReadCell(row, 1);
            if (value != null)
            {
                if (first_is_number)
                {
                    tmp = this._key_map[cast<KEY1>(lua.tonumber(value))];
                    if (tmp == null)
                    {
                        tmp = new Map<KEY2, int>();
                        this._key_map[cast<KEY1>(lua.tonumber(value))] = tmp;
                    }
                }
                else
                {
                    tmp = this._key_map[cast<KEY1>(value)];
                    if (tmp == null)
                    {
                        tmp = new Map<KEY2, int>();
                        this._key_map[cast<KEY1>(value)] = tmp;
                    }
                }
            }

            value = this._csv_file.ReadCell(row, 2);
            if (value != null)
            {
                if (second_is_number)
                    tmp[cast<KEY2>(lua.tonumber(value))] = row;
                else
                    tmp[cast<KEY2>(value)] = row;
            }
        }
    }

    public fun GetData(KEY1 first_key, KEY2 second_key) : T
    {
        if (this._csv_file == null) return null;

        auto value_map = this._cache_map[first_key];
        if (value_map != null)
        {
            auto value = value_map[second_key];
            if (value != null) return value;
        }

        auto key_tmp = this._key_map[first_key];
        if (key_tmp == null) return null;

        int row = key_tmp[second_key];
        if (row == null) return null;

        auto value = this.LoadCell<T>(row);
        if (value == null) return null;

        auto tmp = this._cache_map[first_key];
        if (tmp == null)
        {
            tmp = new Map<KEY2, T>();
            this._cache_map[first_key] = tmp;
        }
        tmp[second_key] = value;
        return value;
    }
}