namespace ALittle;


private auto byte = lua.String.byte;
private auto sub = lua.String.sub;
private auto len = lua.String.len;
private auto find = Find;
private auto concat = lua.table.concat;
private auto type = lua.type;
private auto tostring = lua.tostring;
private auto tonumber = lua.tonumber;
private auto floor = lua.math.floor;
private auto time = lua.os.time;
private auto maxn = lua.table.maxn;
private auto random = lua.math.random;

// 深度复制表
public static String_CopyTable(any info) : any
{
    Map<any, any> new_info = new Map<any, any>();
    for (any key, any value in cast<Map<any, any> >(info))
    {
        if (type(value) != "table")
            new_info[key] = value;
        else
            new_info[key] = String_CopyTable(value);
    }
    return new_info;
}

// 去掉前后空格
public static String_Trim(string content) :string
{
    return A_ScriptSystem.Trim(content);
}

// 根据分隔符拆分字符串成列表，正常版本
public static String_Split(string target, string sep) : List<string>
{
    if (target == null)
        return new List<string>();
    if (sep == null || sep == "")
        sep = ":";
    List<string> fields = new List<string>();
    int fields_count = 0;
    int start_pos = 1;
    while (true)
    {
        int start_index = find(target, sep, start_pos);
        if (start_index == null)
        {
            ++fields_count;
            fields[fields_count] = sub(target, start_pos);
            break;
        }
        ++fields_count;
        fields[fields_count] = sub(target, start_pos, start_index - 1);
        start_pos = start_index + len(sep);
    }
    return fields;
}

// 根据分隔符拆分字符串成列表，正常版本
public static String_SplitSepList(string target, List<string> sep_list) : List<string>
{
    if (target == null) return new List<string>();
    if (sep_list == null) sep_list = new List<string>();

    List<string> fields = new List<string>();
    int fields_count = 0;
    int start_pos = 1;
    while (true)
    {
        int start_index;
        int end_index;
        for (int _, string sep in sep_list)
        {
            int start_index_tmp = find(target, sep, start_pos);
            if (start_index_tmp != null)
            {
                if (start_index == null || start_index_tmp < start_index)
                {
                    start_index = start_index_tmp;
                    end_index = start_index + len(sep) - 1;
                }
            }
        }
        if (start_index == null)
        {
            string value = sub(target, start_pos);
            if (len(value) > 0)
            {
                ++ fields_count;
                fields[fields_count] = sub(target, start_pos);
            }
            break;
        }

        string value = sub(target, start_pos, start_index - 1);
        if (len(value) > 0)
        {
            ++ fields_count;
            fields[fields_count] = sub(target, start_pos, start_index - 1);
        }
        start_pos = end_index + 1;
    }
    return fields;
}

// 把列表以分隔符合并成字符串
public static String_Join(List<any> list, string sep) : string
{
    return concat(list, sep);
}

// 往Url尾巴添加参数
public static String_UrlAppendParam(string url, string param) : string
{
    if (find(url, "?", 1) == null)
        url = url .. "?";
    else
        url = url .. "&";

    return url .. param;
}
public static String_UrlAppendParamMap(string url, Map<string, any> param) : string
{
    List<string> list = new List<string>();
    int count = 0;
    for (auto key, auto value in param)
    {
        ++ count;
        list[count] = key.."="..tostring(value);
    }

    if (find(url, "?", 1) == null)
        url = url .. "?";
    else
        url = url .. "&";

    return url .. String_Join(list, "&");
}

// 把Url解析成需要的信息
struct UrlAnalyseInfo
{
    string protocol;
    string ip;
    int port;
    string path;
    Map<string, string> value_map;
}
public static String_UrlAnalyse(string url) : UrlAnalyseInfo
{
    UrlAnalyseInfo info = new UrlAnalyseInfo();
    info.value_map = new Map<string, string>();

    int start_pos = 1;
    int start_index = find(url, "http://", start_pos);
    if (start_index != null)
    {
        info.protocol = "http";
        start_pos = start_index + len("http://");
    }
    else
    {
        start_index = find(url, "https://", start_pos);
        if (start_index != null)
        {
            info.protocol = "https";
            start_pos = start_index + len("https://");
        }
    }

    string ip_and_port = null;
    start_index = find(url, "/", start_pos);
    if (start_index != null)
        ip_and_port = sub(url, start_pos, start_index - 1);
    else
        ip_and_port = sub(url, start_pos);

    int ip_start = find(ip_and_port, ":", 1);
    if (ip_start != null)
    {
        info.ip = sub(ip_and_port, 1, ip_start - 1);
        info.port = floor(tonumber(sub(ip_and_port, ip_start + 1)));
    }
    else
    {
        info.ip = ip_and_port;
        info.port = 80;
        if (info.protocol == "https")
            info.port = 443;
    }

    if (start_index == null)
        return info;

    start_pos = start_index;
    start_index = find(url, "?", start_pos);
    if (start_index != null)
        info.path = sub(url, start_pos, start_index - 1);
    else
        info.path = sub(url, start_pos);

    if (start_index == null)
        return info;

    start_pos = start_index + 1;

    List<string> param_list = String_Split(sub(url, start_pos), "&");
    for (int k, string v in param_list)
    {
        List<string> param_list_list = String_Split(v, "=");
        if (param_list_list[1] != null && param_list_list[2] != null)
            info.value_map[param_list_list[1]] = param_list_list[2];
    }

    return info;
}

class StringGenerateID
{
    private int _string_last_time;
    private int _string_last_index;

    public Ctor()
    {
        this._string_last_index = 0;
        this._string_last_time = 0;
    }

    public fun GenID(string pre) : string
    {
        int cur_time = time();
        if (cur_time != this._string_last_time)
        {
            this._string_last_time = cur_time;
            this._string_last_index = 0;
        }
        else
        {
            ++ this._string_last_index;
        }
        string result = "";
        if (pre != null)
            result = pre .. "-";
        result = result .. this._string_last_time .. "-" .. this._string_last_index .. "-" .. random(0, 10000) .. "-" .. random(0, 10000);
        return result;
    }
}

private StringGenerateID A_StringGenerateID = new StringGenerateID();

// 生成ID
public static String_GenerateID(string pre) : string
{
    return A_StringGenerateID.GenID(pre);
}

// 替换
public static String_Replace(string content, string old_split, string new_split) : string
{
    auto list = String_Split(content, old_split);
    return String_Join(list, new_split);
}

// 判断是不是手机号码
public static String_IsPhoneNumber(string number) : bool
{
    auto l = len(number);
    for (auto i = 1, l, 1)
    {
        auto value = byte(number, i);
        if (value < 48) return false;
        if (value > 57) return false;
    }

    return true;
}

// 参数解析
public static String_HttpAnalysisValueMap(string param, string content) : Map<string, any>
{
    auto value_map = new Map<string, any>();
    auto param_split_list = ALittle.String_Split(param, "&");
    for (auto index, auto param_content in param_split_list)
    {
        auto value_split_list = ALittle.String_Split(param_content, "=");
        if (maxn(value_split_list) == 2)
        {
            if (sub(value_split_list[2], 1, 1) == "\""
                && sub(value_split_list[2], -1, -1) == "\"")
            {
                value_map[value_split_list[1]] = sub(value_split_list[2], 2, -2);
            }
            else
            {
                auto number = ALittle.tonumber(value_split_list[2]);
                if (number == null)
                    value_map[value_split_list[1]] = value_split_list[2];
                else
                    value_map[value_split_list[1]] = number;
            }
        }
    }

    if (len(content) > 0)
    {
        auto error, Map<string, any> value = tcall(lua.json.decode, content);
        if (error == null)
        {
            for (auto k, auto v in value)
                value_map[k] = v;
        }
    }

    return value_map;
}

// 把UTF8拆分成以一个字为单位的列表
struct SplitUTF8Info
{
    List<string> list;
    int count;
}

public static String_SplitUTF8(string content, SplitUTF8Info out)
{
    List<string> result = new List<string>();
    int l = len(content);
    int offset = 0;
    int count = 0;
    while (l > offset)
    {
        int byte_count = A_ScriptSystem.GetUTF8ByteCountByOffset(content, offset);
        ++ count;
        result[count] = sub(content, offset + 1, offset + byte_count);
        offset = offset + byte_count;
    }

    out.list = result;
    out.count = count;
}

// 对字符串进行md5
// param content
// return md5
public static String_MD5(string content) : string
{
    return A_ScriptSystem.StringMD5(content);
}

// 计算一个文件的MD5
// param file_path
// return md5 如果文件不存在会返回空串
public static String_FileMD5(string path) :string
{
    return A_ScriptSystem.FileMD5(path);
}

// sha1加密
public static String_Sha1(string content) : string
{
    return A_ScriptSystem.Sha1(content);
}
// base64解密
public static String_Base64Decode(string content) : string
{
    return A_ScriptSystem.Base64Decode(content);
}
// base64加密
public static String_Base64Encode(string content) : string
{
    return A_ScriptSystem.Base64Encode(content);
}
// UTF8 转 GBK (注意：只在windows平台有转换，其他平台不做转换直接不变传回来)
public static String_UTF8ToGBK(string content) : string
{
    return A_ScriptSystem.UTF82GBK(content);
}
// GBK 转 UTF8 (注意：只在windows平台有转换，其他平台不做转换直接不变传回来)
public static String_GBKToUTF8(string content) : string
{
    return A_ScriptSystem.GBK2UTF8(content);
}
// 获取UTF8的字的个数
public static String_GetUTF8Length(string content) : int
{
    return A_ScriptSystem.GetUTF8Length(content);
}
// 获取UTF8的字的字节数
public static String_CalcUTF8LengthOfWord(string content, int word_count) : int
{
    return A_ScriptSystem.CalcUTF8LengthOfWord(content, word_count);
}

// 把时间转为，XX天XX小时XX分钟XX秒
public static String_FormatTime2Remain(int remain_time) : string
{
    string room_time_desc = "";
    if (remain_time > TimeSecond.ONE_DAY_SECONDS)
    {
        int count = lua.math.floor(remain_time / TimeSecond.ONE_DAY_SECONDS);
        remain_time = remain_time - count * TimeSecond.ONE_DAY_SECONDS;
        room_time_desc = room_time_desc..count.."天";
    }
    if (remain_time > TimeSecond.ONE_HOUR_SECONDS)
    {
        int count = lua.math.floor(remain_time / TimeSecond.ONE_HOUR_SECONDS);
        remain_time = remain_time - count * TimeSecond.ONE_HOUR_SECONDS;
        room_time_desc = room_time_desc..count.."小时";
    }
    if (remain_time > TimeSecond.ONE_MINUTE_SECONDS)
    {
        int count = lua.math.floor(remain_time / TimeSecond.ONE_MINUTE_SECONDS);
        remain_time = remain_time - count * TimeSecond.ONE_MINUTE_SECONDS;
        room_time_desc = room_time_desc..count.."分钟";
    }
    if (remain_time > 0)
    {
        int count = lua.math.floor(remain_time / TimeSecond.ONE_MINUTE_SECONDS);
        remain_time = remain_time - count * TimeSecond.ONE_MINUTE_SECONDS;
        room_time_desc = room_time_desc..remain_time.."秒";
    }

    return room_time_desc;
}
