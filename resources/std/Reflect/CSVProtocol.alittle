
namespace ALittle;

public class ICSVFile
{
    public fun Close() {}
    public fun ReadCell(int lua_row, int lua_col) : string {}
    public fun GetRowCount() : int {}
    public fun GetColCount() : int {}
}

public struct CSVInvokeInfo
{
    Functor<(string, CSVInvokeInfo):any> func;

    // 当这个结构体是上级的成员变量时，那么这个不为空
    string var_name;

    // 如果是List
    string split;
    CSVInvokeInfo sub_info;

    // 如果是message，表示列表
    List<CSVInvokeInfo> handle;
}

//回调注册部分//////////////////////////////////////////////////////////////////////////////////////////////////////////-

private auto floor = lua.math.floor;
private auto tonumber = lua.tonumber;
private auto maxn = lua.table.maxn;

private static CSV_ReadBool(string content, CSVInvokeInfo value) : bool
{
    return content == "true";
}

private static CSV_ReadInt(string content, CSVInvokeInfo value) : int
{
    if (content == "") return 0;
    return floor(tonumber(content));
}

private static CSV_ReadLongLong(string content, CSVInvokeInfo value) : I64
{
    if (content == "") return 0;
    return floor(tonumber(content));
}

private static CSV_ReadString(string content, CSVInvokeInfo value) : string
{
    return content;
}

private static CSV_ReadDouble(string content, CSVInvokeInfo value) : double
{
    if (content == "") return 0;
    return tonumber(content);
}

private static CSV_ReadArray(string content, CSVInvokeInfo value) : List<any>
{
    auto list = String_Split(content, value.split);
    List<any> result = new List<any>();
    for (auto index, auto sub in list)
    {
        auto v = value.func(sub, value.sub_info);
        if (v == null) return null;
        result[index] = v;
    }
    return result;
}

protected static CSV_ReadMessage(string content, CSVInvokeInfo value) : any
{
    auto list = String_Split(content, value.split);
    Map<string, any> t = new Map<string, any>();
    for (auto index, auto handle in value.handle)
    {
        t[handle.var_name] = handle.func(list[index], handle);
    }
    return t;
}

private auto __csv_read_data_map = new Map<string, any>();
__csv_read_data_map["bool"] = CSV_ReadBool;
__csv_read_data_map["int"] = CSV_ReadInt;
__csv_read_data_map["I64"] = CSV_ReadLongLong;
__csv_read_data_map["string"] = CSV_ReadString;
__csv_read_data_map["double"] = CSV_ReadDouble;

protected auto __split_list = ["#","*","|"];
protected auto __split_list_last = __split_list[maxn(__split_list)];

//构造部分//////////////////////////////////////////////////////////////////////////////////////////////////////////-
private auto find = Find;
private auto sub = lua.String.sub;
protected static CreateCSVSubInfo(string sub_type, int split_index) : CSVInvokeInfo
{
    if (find(sub_type, "List", 1) == 1)
        return CreateCSVArrayInfo(sub_type, split_index);

    if (find(sub_type, "Map", 1) == 1)
        assert(false, "不支持Map解析");

    auto func = __csv_read_data_map[sub_type];
    if (func != null)
    {
        auto sub_info = new CSVInvokeInfo();
        sub_info.func = func;
        return sub_info;
    }

    return CreateCSVInfoImpl(sub_type, split_index);
}

protected static CreateCSVArrayInfo(string var_type, int split_index) : CSVInvokeInfo
{
    assert(split_index > 0, "分隔符数量不足");

    auto invoke_info = new CSVInvokeInfo();
    invoke_info.func = CSV_ReadArray;
    invoke_info.split = __split_list[split_index];
    invoke_info.sub_info = CreateCSVSubInfo(sub(var_type, 6, -2), split_index - 1);
    return invoke_info;
}

protected static CreateCSVInfoImpl(string var_type, int split_index) : CSVInvokeInfo
{
    assert(split_index > 0, "分隔符数量不足");

    auto reflect_info = FindReflectByName(var_type);
    assert(reflect_info != null, "FindReflectByName调用失败! 未知类型:" .. var_type);

    auto invoke_info = new CSVInvokeInfo();
    invoke_info.split = __split_list[split_index];
    invoke_info.func = CSV_ReadMessage;

    auto handle = new List<CSVInvokeInfo>();
    invoke_info.handle = handle;
    auto handle_count = 0;
    for (auto index, auto var_name in reflect_info.name_list)
    {
        auto var_info = CreateCSVSubInfo(reflect_info.type_list[index], split_index - 1);
        var_info.var_name = var_name;
        handle_count = handle_count + 1;
        handle[handle_count] = var_info;
    }
    return invoke_info;
}

protected static CreateCSVInfo(StructInfo reflect_info) : CSVInvokeInfo
{
    int split_index = maxn(__split_list);
    assert(split_index > 0, "分隔符数量不足");

    auto invoke_info = new CSVInvokeInfo();
    invoke_info.split = __split_list[split_index];
    invoke_info.func = CSV_ReadMessage;

    auto handle = new List<CSVInvokeInfo>();
    invoke_info.handle = handle;
    auto handle_count = 0;
    for (auto index, auto var_name in reflect_info.name_list)
    {
        auto var_info = CreateCSVSubInfo(reflect_info.type_list[index], split_index - 1);
        var_info.var_name = var_name;
        handle_count = handle_count + 1;
        handle[handle_count] = var_info;
    }
    return invoke_info;
}
